From b6d2e37cb78f3a21e2b33e6e956a042b8b58201a Mon Sep 17 00:00:00 2001
From: G Anthony <a0783926@ti.com>
Date: Fri, 9 Dec 2011 15:12:28 -0800
Subject: [PATCH 3/5] IPC: A BIOS MessageQ Transport over VirtQueue/Virtio

This is a prototype of a BIOS IPC transport for MessageQ, over vrings.

It currently supports communication:
- Linux A9 to BIOS Ducati sysM3 (CORE0);
- Ducati AppM3 (CORE1) to sysM3 (CORE0).

This requires Linux side MessageQ source code to be found in:
	https://github.com/GAnthony/syslink3

Current Constraints:
* This is *not* compatible with MessageQCopy or its current client code;
* NameServer is not yet implemented.
* Only sends to a MessageQ endpoint on Linux side at rpmsg chnl = 1024.

Signed-off-by: G Anthony <a0783926@ti.com>
---
 src/ti/examples/srvmgr/test_omx.c              |    2 +-
 src/ti/ipc/rpmsg/InterruptM3.c                 |    2 +-
 src/ti/ipc/rpmsg/MessageQCopy.c                |    6 +-
 src/ti/ipc/rpmsg/VirtQueue.c                   |  228 +++++++----
 src/ti/ipc/rpmsg/VirtQueue.h                   |    8 +-
 src/ti/ipc/rpmsg/_VirtQueue.h                  |  102 +++++
 src/ti/ipc/tests/message_noipc_core0.c         |  223 +++++++++
 src/ti/ipc/tests/message_noipc_core0.cfg       |   36 ++
 src/ti/ipc/tests/message_noipc_core1.c         |  218 +++++++++
 src/ti/ipc/tests/message_noipc_core1.cfg       |   36 ++
 src/ti/ipc/tests/messageq_bench.cfg            |  109 +++++
 src/ti/ipc/tests/messageq_socket.c             |  222 +++++++++
 src/ti/ipc/tests/messageq_socket.cfg           |   36 ++
 src/ti/ipc/tests/package.bld                   |   68 +++
 src/ti/ipc/tests/package.xdc                   |   43 ++
 src/ti/ipc/tests/package.xs                    |   41 ++
 src/ti/ipc/tests/tests_common.cfg.xs           |  128 ++++++
 src/ti/ipc/transports/TransportVirtio.c        |  575 ++++++++++++++++++++++++
 src/ti/ipc/transports/TransportVirtio.xdc      |   81 ++++
 src/ti/ipc/transports/TransportVirtio.xs       |   55 +++
 src/ti/ipc/transports/TransportVirtioSetup.c   |  114 +++++
 src/ti/ipc/transports/TransportVirtioSetup.xdc |   52 +++
 src/ti/ipc/transports/TransportVirtioSetup.xs  |   63 +++
 src/ti/ipc/transports/_TransportVirtio.h       |   39 ++
 src/ti/ipc/transports/package.bld              |   55 +++
 src/ti/ipc/transports/package.xdc              |   44 ++
 src/ti/ipc/transports/package.xs               |   97 ++++
 27 files changed, 2599 insertions(+), 84 deletions(-)
 create mode 100644 src/ti/ipc/rpmsg/_VirtQueue.h
 create mode 100644 src/ti/ipc/tests/message_noipc_core0.c
 create mode 100644 src/ti/ipc/tests/message_noipc_core0.cfg
 create mode 100644 src/ti/ipc/tests/message_noipc_core1.c
 create mode 100644 src/ti/ipc/tests/message_noipc_core1.cfg
 create mode 100644 src/ti/ipc/tests/messageq_bench.cfg
 create mode 100644 src/ti/ipc/tests/messageq_socket.c
 create mode 100644 src/ti/ipc/tests/messageq_socket.cfg
 create mode 100644 src/ti/ipc/tests/package.bld
 create mode 100644 src/ti/ipc/tests/package.xdc
 create mode 100644 src/ti/ipc/tests/package.xs
 create mode 100644 src/ti/ipc/tests/tests_common.cfg.xs
 create mode 100644 src/ti/ipc/transports/TransportVirtio.c
 create mode 100644 src/ti/ipc/transports/TransportVirtio.xdc
 create mode 100644 src/ti/ipc/transports/TransportVirtio.xs
 create mode 100644 src/ti/ipc/transports/TransportVirtioSetup.c
 create mode 100644 src/ti/ipc/transports/TransportVirtioSetup.xdc
 create mode 100644 src/ti/ipc/transports/TransportVirtioSetup.xs
 create mode 100644 src/ti/ipc/transports/_TransportVirtio.h
 create mode 100644 src/ti/ipc/transports/package.bld
 create mode 100644 src/ti/ipc/transports/package.xdc
 create mode 100644 src/ti/ipc/transports/package.xs

diff --git a/src/ti/examples/srvmgr/test_omx.c b/src/ti/examples/srvmgr/test_omx.c
index 3ab9466..851f235 100644
--- a/src/ti/examples/srvmgr/test_omx.c
+++ b/src/ti/examples/srvmgr/test_omx.c
@@ -226,7 +226,7 @@ Int main(Int argc, char* argv[])
 #endif
 
     /* Plug vring interrupts, and spin until host handshake complete. */
-    VirtQueue_startup();
+    VirtQueue_startup(0);
 
     /*
      * Enable use of runtime Diags_setMask per module:
diff --git a/src/ti/ipc/rpmsg/InterruptM3.c b/src/ti/ipc/rpmsg/InterruptM3.c
index c95876b..4d62415 100644
--- a/src/ti/ipc/rpmsg/InterruptM3.c
+++ b/src/ti/ipc/rpmsg/InterruptM3.c
@@ -265,7 +265,7 @@ Void InterruptM3_isr(UArg arg)
     payload = InterruptM3_intClear();
     if (payload != InterruptM3_INVALIDPAYLOAD) {
         Log_print1(Diags_USER1,
-            "InterruptM3_isr: Interrupt received, payload = 0x%x\n",
+            "InterruptM3_isr: Interrupt received, payload = 0x%x",
             (IArg)payload);
         userFxn(payload);
     }
diff --git a/src/ti/ipc/rpmsg/MessageQCopy.c b/src/ti/ipc/rpmsg/MessageQCopy.c
index 389b463..13dc75c 100644
--- a/src/ti/ipc/rpmsg/MessageQCopy.c
+++ b/src/ti/ipc/rpmsg/MessageQCopy.c
@@ -92,7 +92,7 @@ typedef struct MessageQCopy_Module {
     HeapBuf_Handle              heap;
 } MessageQCopy_Module;
 
-/* Message Header: Must match mp_msg_hdr in virtio_rp_msg.h on Linux side. */
+/* Message Header: Must match rp_msg_hdr in virtio_rp_msg.h on Linux side. */
 typedef struct MessageQCopy_MsgHeader {
     Bits32 srcAddr;                 /* source endpoint addr               */
     Bits32 dstAddr;                 /* destination endpoint addr          */
@@ -246,9 +246,9 @@ Void MessageQCopy_init(UInt16 remoteProcId)
      * the vrings toHost and fromHost:  toHost is first!
      */
     transport.virtQueue_toHost   = VirtQueue_create(callback_availBufReady,
-                                                    remoteProcId);
+                                                    remoteProcId, NULL);
     transport.virtQueue_fromHost = VirtQueue_create(callback_availBufReady,
-                                                    remoteProcId);
+                                                    remoteProcId, NULL);
 
     /* construct the Swi to process incoming messages: */
     transport.swiHandle = Swi_create(MessageQCopy_swiFxn, NULL, NULL);
diff --git a/src/ti/ipc/rpmsg/VirtQueue.c b/src/ti/ipc/rpmsg/VirtQueue.c
index 0f3abda..6953d6b 100644
--- a/src/ti/ipc/rpmsg/VirtQueue.c
+++ b/src/ti/ipc/rpmsg/VirtQueue.c
@@ -39,8 +39,6 @@
  *  - BIOS (XDC) types and CamelCasing used;
  *  - virtio_device concept removed (i.e, assumes no containing device);
  *  - simplified scatterlist from Linux version;
- *  - VirtQueue_Objects are created statically here, so just added a VirtQueue_Object_init()
- *    fxn to take the place of the Virtio vring_new_virtqueue() API;
  *  - The notify function is implicit in the implementation, and not provided
  *    by the client, as it is in Linux virtio.
  *
@@ -61,38 +59,30 @@
 #include <xdc/runtime/Diags.h>
 
 #include <ti/sysbios/hal/Hwi.h>
-#include <ti/sysbios/knl/Semaphore.h>
 #include <ti/sysbios/knl/Clock.h>
 #include <ti/sysbios/BIOS.h>
 #include <ti/sysbios/hal/Cache.h>
 
 #include <ti/ipc/rpmsg/InterruptM3.h>
-#include <ti/ipc/rpmsg/VirtQueue.h>
 #include <ti/pm/IpcPower.h>
 
 #include <ti/ipc/MultiProc.h>
 
 #include <string.h>
 
-#include "virtio_ring.h"
-
-/* Used for defining the size of the virtqueue registry */
-#define NUM_QUEUES                      5
-
-/* Predefined device addresses */
-#define IPU_MEM_VRING0          0xA0000000
-#define IPU_MEM_VRING1          0xA0004000
-#define IPU_MEM_VRING2          0xA0008000
-#define IPU_MEM_VRING3          0xA000c000
+#include <ti/ipc/rpmsg/virtio_ring.h>
+#include <ti/ipc/rpmsg/VirtQueue.h>
+#include <ti/ipc/rpmsg/_VirtQueue.h>
 
 /*
- * Sizes of the virtqueues (expressed in number of buffers supported,
- * and must be power of two)
+ * Define APPM3_IS_HOST to enable VirtioTransport test where appM3 is host and
+ * sysM3 is slave.  Otherwise, VirtQueue defaults to Linux/A9 as host, and
+ * appM3 and sysM3 as slaves (where sysM3 routes interrupts to appM3).
  */
-#define VQ0_SIZE                256
-#define VQ1_SIZE                256
-#define VQ2_SIZE                256
-#define VQ3_SIZE                256
+//#define APPM3_IS_HOST
+
+/* Used for defining the size of the virtqueue registry */
+#define NUM_QUEUES                      5
 
 /*
  * enum - Predefined Mailbox Messages
@@ -130,8 +120,6 @@ enum {
 };
 
 #define DIV_ROUND_UP(n,d)   (((n) + (d) - 1) / (d))
-#define RP_MSG_NUM_BUFS     (VQ0_SIZE) /* must be power of two */
-#define RP_MSG_BUF_SIZE     (512)
 #define RP_MSG_BUFS_SPACE   (RP_MSG_NUM_BUFS * RP_MSG_BUF_SIZE * 2)
 
 #define PAGE_SIZE           (4096)
@@ -154,29 +142,6 @@ enum {
 #define ID_APPM3_TO_A9      2
 #define ID_A9_TO_APPM3      3
 
-typedef struct VirtQueue_Object {
-    /* Id for this VirtQueue_Object */
-    UInt16                  id;
-
-    /* The function to call when buffers are consumed (can be NULL) */
-    VirtQueue_callback      callback;
-
-    /* Shared state */
-    struct vring            vring;
-
-    /* Number of free buffers */
-    UInt16                  num_free;
-
-    /* Last available index; updated by VirtQueue_getAvailBuf */
-    UInt16                  last_avail_idx;
-
-    /* Last available index; updated by VirtQueue_addUsedBuf */
-    UInt16                  last_used_idx;
-
-    /* Will eventually be used to kick remote processor */
-    UInt16                  procId;
-} VirtQueue_Object;
-
 static UInt numQueues = 0;
 static struct VirtQueue_Object *queueRegistry[NUM_QUEUES];
 
@@ -185,6 +150,10 @@ static UInt16 dspProcId;
 static UInt16 sysm3ProcId;
 static UInt16 appm3ProcId;
 
+#ifdef APPM3_IS_HOST
+static UInt16 synced = 0;
+#endif
+
 static inline Void * mapPAtoVA(UInt pa)
 {
     return (Void *)((pa & 0x000fffffU) | 0xa0000000U);
@@ -220,6 +189,10 @@ Int VirtQueue_addUsedBuf(VirtQueue_Handle vq, Int16 head)
 {
     struct vring_used_elem *used;
 
+    Log_print3(Diags_USER1,
+       "addUsedBuf vq->id: %d head: %d used->idx: %d",
+        vq->id, head, vq->vring.used->idx);
+
     if ((head > vq->vring.num) || (head < 0)) {
         Error_raise(NULL, Error_E_generic, 0, 0);
     }
@@ -244,11 +217,14 @@ Int VirtQueue_addAvailBuf(VirtQueue_Object *vq, Void *buf)
 {
     UInt16 avail;
 
+    Log_print3(Diags_USER1,
+       "addAvailBuf vq->id: %d vq->num_free: %d avail->idx: %d",
+        vq->id, vq->num_free, vq->vring.avail->idx);
+
     if (vq->num_free == 0) {
         /* There's no more space */
         Error_raise(NULL, Error_E_generic, 0, 0);
     }
-
     vq->num_free--;
 
     avail =  vq->vring.avail->idx++ % vq->vring.num;
@@ -267,6 +243,10 @@ Void *VirtQueue_getUsedBuf(VirtQueue_Object *vq)
     UInt16 head;
     Void *buf;
 
+    Log_print3(Diags_USER1,
+       "getUsedBuf vq->id: %d last_used_idx: %d used->idx: %d",
+        vq->id, vq->last_used_idx, vq->vring.used->idx);
+
     /* There's nothing available? */
     if (vq->last_used_idx == vq->vring.used->idx) {
         return (NULL);
@@ -274,6 +254,7 @@ Void *VirtQueue_getUsedBuf(VirtQueue_Object *vq)
 
     head = vq->vring.used->ring[vq->last_used_idx % vq->vring.num].id;
     vq->last_used_idx++;
+    vq->num_free++;
 
     buf = mapPAtoVA(vq->vring.desc[head].addr);
 
@@ -287,28 +268,40 @@ Int16 VirtQueue_getAvailBuf(VirtQueue_Handle vq, Void **buf)
 {
     UInt16 head;
 
-    Log_print6(Diags_USER1, "getAvailBuf vq: 0x%x %d %d %d 0x%x 0x%x\n",
-	(IArg)vq,
-        vq->last_avail_idx, vq->vring.avail->idx, vq->vring.num,
-        (IArg)&vq->vring.avail, (IArg)vq->vring.avail);
+    Log_print5(Diags_USER1,
+       "getAvailBuf vq->id: %d last_avail_idx: %d avail->idx: %d num: %d 0x%x",
+        vq->id, vq->last_avail_idx, vq->vring.avail->idx, vq->vring.num,
+        (IArg)&vq->vring.avail);
 
     /* There's nothing available? */
     if (vq->last_avail_idx == vq->vring.avail->idx) {
-        /* We need to know about added buffers */
-        vq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
-        /* check again after setting flag */
-        if (vq->last_avail_idx == vq->vring.avail->idx)
-            return -1;
+        if (VirtQueue_isHost(vq))  {
+            /* We need to know about added buffers */
+            vq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
+            /* check again after setting flag */
+            if (vq->last_avail_idx == vq->vring.avail->idx)  {
+                return (-1);
+            }
+       }
+       else {
+            return (-1);
+       }
     }
 
-    /* No need to know be kicked about added buffers anymore */
-    vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
+    /* No need to be kicked about added buffers anymore */
+    if (VirtQueue_isHost(vq))  {
+        vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
+    }
 
     /*
      * Grab the next descriptor number they're advertising, and increment
      * the index we've seen.
      */
+#ifndef APPM3_IS_HOST  /* This line works with Linux rpmsg Host: */
     head = vq->vring.avail->ring[vq->last_avail_idx++ % vq->vring.num];
+#else  /* This line works with both Linux and appM3 as rpmsg Hosts: */
+    head = vq->last_avail_idx++ % vq->vring.num;
+#endif
 
     *buf = mapPAtoVA(vq->vring.desc[head].addr);
 
@@ -335,6 +328,72 @@ Bool VirtQueue_enableCallback(VirtQueue_Object *vq)
     return (FALSE);
 }
 
+#ifdef APPM3_IS_HOST
+/*!
+ * ======== VirtQueue_isr ========
+ * Note 'arg' is ignored: it is the Hwi argument, not the mailbox argument.
+ */
+Void VirtQueue_isr(UArg msg)
+{
+    VirtQueue_Object *vq;
+
+    Log_print1(Diags_USER1, "VirtQueue_isr received msg = 0x%x\n", msg);
+
+    if (MultiProc_self() == sysm3ProcId) {
+        switch(msg) {
+            case (UInt)RP_MSG_MBOX_READY:
+                return;
+
+            case (UInt)RP_MBOX_ECHO_REQUEST:
+                InterruptM3_intSend(appm3ProcId, (UInt)(RP_MBOX_ECHO_REPLY));
+                synced = 1;
+                return;
+
+            case (UInt)RP_MBOX_ABORT_REQUEST:
+                {
+                    Fxn f = (Fxn)0x0;
+                    Log_print0(Diags_USER1, "Crash on demand ...\n");
+                    f();
+                }
+                return;
+
+            case (UInt)RP_MSG_FLUSH_CACHE:
+                Cache_wbAll();
+                return;
+
+            case (UInt)RP_MSG_HIBERNATION:
+                /* Notify Core1 */
+                InterruptM3_intSend(appm3ProcId, (UInt)(RP_MSG_HIBERNATION));
+                IpcPower_suspend();
+                return;
+
+            default:
+                /*
+                 *  If the message isn't one of the above, it's either part of the
+                 *  2-message synchronization sequence or it a virtqueue message
+                 */
+                break;
+        }
+    }
+    else if (msg & 0xFFFF0000) {
+        if (msg == (UInt)RP_MSG_HIBERNATION) {
+            IpcPower_suspend();
+        }
+        if ((MultiProc_self() == appm3ProcId) &&
+             (msg == (UInt)(RP_MBOX_ECHO_REPLY)))  {
+           synced = 1;
+        }
+        return;
+    }
+
+    vq = queueRegistry[msg];
+    if (vq) {
+        vq->callback(vq);
+    }
+}
+
+#else
+
 /*!
  * ======== VirtQueue_isr ========
  * Note 'arg' is ignored: it is the Hwi argument, not the mailbox argument.
@@ -387,7 +446,8 @@ Void VirtQueue_isr(UArg msg)
         return;
     }
 
-    if (MultiProc_self() == sysm3ProcId && (msg == ID_A9_TO_APPM3 || msg == ID_APPM3_TO_A9)) {
+    if (MultiProc_self() == sysm3ProcId &&
+            (msg == ID_A9_TO_APPM3 || msg == ID_APPM3_TO_A9)) {
         InterruptM3_intSend(appm3ProcId, (UInt)msg);
     }
     else {
@@ -397,13 +457,13 @@ Void VirtQueue_isr(UArg msg)
         }
     }
 }
-
+#endif
 
 /*!
  * ======== VirtQueue_create ========
  */
 VirtQueue_Object *VirtQueue_create(VirtQueue_callback callback,
-        UInt16 remoteProcId)
+        UInt16 remoteProcId, UArg arg)
 {
     VirtQueue_Object *vq;
     void *vring_phys;
@@ -420,10 +480,15 @@ VirtQueue_Object *VirtQueue_create(VirtQueue_callback callback,
     vq->id = numQueues++;
     vq->procId = remoteProcId;
     vq->last_avail_idx = 0;
+    vq->last_used_idx = 0;
+    vq->num_free = RP_MSG_NUM_BUFS;
+    vq->arg = arg;
 
+#ifndef APPM3_IS_HOST
     if (MultiProc_self() == appm3ProcId) {
         vq->id += 2;
     }
+#endif
 
     switch (vq->id) {
         case ID_SYSM3_TO_A9:
@@ -441,19 +506,11 @@ VirtQueue_Object *VirtQueue_create(VirtQueue_callback callback,
     }
 
     Log_print3(Diags_USER1,
-            "vring: %d 0x%x (0x%x)\n", vq->id, (IArg)vring_phys,
+            "vring: %d 0x%x (0x%x)", vq->id, (IArg)vring_phys,
             RP_MSG_RING_SIZE);
 
     vring_init(&(vq->vring), RP_MSG_NUM_BUFS, vring_phys, RP_MSG_VRING_ALIGN);
 
-    /*
-     *  Don't trigger a mailbox message every time A8 makes another buffer
-     *  available
-     */
-    if (vq->procId == hostProcId || vq->procId == dspProcId) {
-        vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
-    }
-
     queueRegistry[vq->id] = vq;
 
     return (vq);
@@ -462,7 +519,7 @@ VirtQueue_Object *VirtQueue_create(VirtQueue_callback callback,
 /*!
  * ======== VirtQueue_startup ========
  */
-Void VirtQueue_startup()
+Void VirtQueue_startup(Bool isHost)
 {
     hostProcId      = MultiProc_getId("HOST");
     dspProcId       = MultiProc_getId("DSP");
@@ -472,16 +529,33 @@ Void VirtQueue_startup()
     /* Initilize the IpcPower module */
     IpcPower_init();
 
-    /*
-     *  DSP can be used to prototype communications with CORE0 instead of
-     *  HOST
-     */
-    if (MultiProc_self() == dspProcId) {
+    if (isHost)  {
+       /* Host is responsible for zeroing out vring memory: */
+       memset((void *)IPU_MEM_VRING0, 0,
+                RP_MSG_RING_SIZE * 2 + RP_MSG_BUFS_SPACE);
+    }
+
+    if (MultiProc_self() == appm3ProcId) {
+        InterruptM3_intRegister(VirtQueue_isr);
     }
-    else if (MultiProc_self() == sysm3ProcId)
+    else if (MultiProc_self() == sysm3ProcId)  {
         InterruptM3_intRegister(VirtQueue_isr);
-    else if (MultiProc_self() == appm3ProcId)
+    }
+    else if (MultiProc_self() == dspProcId)  {
         InterruptM3_intRegister(VirtQueue_isr);
+    }
+
+    if (isHost)  {
+       /* Host sends init sequence to sync slave processor (sysM3): */
+       InterruptM3_intSend(sysm3ProcId, (UInt)RP_MSG_MBOX_READY);
+       InterruptM3_intSend(sysm3ProcId, (UInt)RP_MBOX_ECHO_REQUEST);
+    }
+
+#ifdef APPM3_IS_HOST
+    /* Busy wait until host and slaves have synced: */
+    while (!synced);
+#endif
+    Log_print0(Diags_USER1, "Passed VirtQueue_startup\n");
 }
 
 /*!
diff --git a/src/ti/ipc/rpmsg/VirtQueue.h b/src/ti/ipc/rpmsg/VirtQueue.h
index 9806122..b261f91 100644
--- a/src/ti/ipc/rpmsg/VirtQueue.h
+++ b/src/ti/ipc/rpmsg/VirtQueue.h
@@ -111,10 +111,12 @@ typedef Void (*VirtQueue_callback)(VirtQueue_Handle);
  *
  *  @param[in]  callback  the clients callback function.
  *  @param[in]  procId    Processor ID associated with this VirtQueue.
+ *  @param[in]  arg       Client data associated with this vq.
  *
  *  @Returns    Returns a handle to a new initialized VirtQueue.
  */
-VirtQueue_Handle VirtQueue_create(VirtQueue_callback callback, UInt16 procId);
+VirtQueue_Handle VirtQueue_create(VirtQueue_callback callback, UInt16 procId,
+                                  UArg arg);
 
 
 /*!
@@ -132,8 +134,10 @@ Void VirtQueue_kick(VirtQueue_Handle vq);
  *  @brief       Used at startup-time for initialization
  *
  *  Should be called before any other VirtQueue APIs
+ *
+ *  @param[in]  isHost   True if this processor is acting as a virtio host.
  */
-Void VirtQueue_startup();
+Void VirtQueue_startup(Bool isHost);
 
 
 /*
diff --git a/src/ti/ipc/rpmsg/_VirtQueue.h b/src/ti/ipc/rpmsg/_VirtQueue.h
new file mode 100644
index 0000000..914cddf
--- /dev/null
+++ b/src/ti/ipc/rpmsg/_VirtQueue.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** ============================================================================
+ *  @file       _VirtQueue.h
+ *
+ *  @brief      Virtio Queue private file.
+ *
+ */
+
+
+#ifndef ti_ipc__VirtQueue__include
+#define ti_ipc__VirtQueue__include
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/* Predefined device addresses */
+#define IPU_MEM_VRING0          0xA0000000
+#define IPU_MEM_VRING1          0xA0004000
+#define IPU_MEM_VRING2          0xA0008000
+#define IPU_MEM_VRING3          0xA000c000
+
+/*
+ * Sizes of the virtqueues (expressed in number of buffers supported,
+ * and must be power of two)
+ */
+#define VQ0_SIZE                256
+#define VQ1_SIZE                256
+#define VQ2_SIZE                256
+#define VQ3_SIZE                256
+
+/* See VirtQueue.c also for other constants:   */
+#define RP_MSG_NUM_BUFS     (VQ0_SIZE) /* must be power of two */
+#define RP_MSG_BUF_SIZE     (512)
+
+typedef struct VirtQueue_Object {
+    /* Id for this VirtQueue_Object */
+    UInt16                  id;
+
+    /* The function to call when buffers are consumed (can be NULL) */
+    VirtQueue_callback      callback;
+
+    /* Client object.  */
+    UArg                    arg;
+
+    /* Shared state */
+    struct vring            vring;
+
+    /* Number of free buffers */
+    UInt16                  num_free;
+
+    /* Last available index; updated by VirtQueue_getAvailBuf */
+    UInt16                  last_avail_idx;
+
+    /* Last available index; updated by VirtQueue_addUsedBuf */
+    UInt16                  last_used_idx;
+
+    /* Will eventually be used to kick remote processor */
+    UInt16                  procId;
+
+} VirtQueue_Object;
+
+
+/* By convention, Host VirtQueues host are the even number in the pair */
+#define VirtQueue_isSlave(vq)   (vq->id & 0x1)
+#define VirtQueue_isHost(vq)    (~(vq->id & 0x1))
+
+
+#if defined (__cplusplus)
+}
+#endif /* defined (__cplusplus) */
+#endif /* ti_ipc__VirtQueue__include */
diff --git a/src/ti/ipc/tests/message_noipc_core0.c b/src/ti/ipc/tests/message_noipc_core0.c
new file mode 100644
index 0000000..4f3ab79
--- /dev/null
+++ b/src/ti/ipc/tests/message_noipc_core0.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== message_core0.c ========
+ *  message example on a multiprocessor system
+ *
+ *  This is an example program that uses MessageQ to pass a message
+ *  from one core to another.
+ *
+ *  Each processor creates its own MessageQ first and then will try to open
+ *  a remote processor's MessageQ.
+ */
+
+#include <xdc/std.h>
+#include <string.h>
+
+/*  -----------------------------------XDC.RUNTIME module Headers    */
+#include <xdc/runtime/Error.h>
+#include <xdc/runtime/Assert.h>
+#include <xdc/runtime/Memory.h>
+#include <xdc/runtime/System.h>
+#include <xdc/runtime/IHeap.h>
+#include <xdc/runtime/Diags.h>
+
+/*  ----------------------------------- IPC module Headers           */
+#include <ti/ipc/MessageQ.h>
+#include <ti/ipc/MultiProc.h>
+#include <ti/ipc/transports/TransportVirtioSetup.h>
+
+/*  ----------------------------------- BIOS6 module Headers         */
+#include <ti/sysbios/BIOS.h>
+#include <ti/sysbios/heaps/HeapBuf.h>
+
+/*  ----------------------------------- To get globals from .cfg Header */
+#include <xdc/cfg/global.h>
+
+typedef unsigned int u32;
+#include <ti/resources/rsc_table.h>
+
+
+/*
+ * TBD: This to get the TransportVirtio_attach() called in lieu of "correct"
+ * way to hook in to BIOS Ipc_start().
+ * Must be done after BIOS_start(), as TransportVirtio startup relies on
+ * passing an interrupt handshake.
+ */
+void myIpcStart(UInt procId)
+{
+    Int     status;
+
+    /* call TransportCircSetup to attach to remote processor */
+    status = TransportVirtioSetup_attach(procId, 0);
+
+    Assert_isTrue(status >= 0, NULL);
+}
+
+
+/*
+ *  ======== tsk1_func ========
+ *  Receive and return messages
+ */
+Void tsk1_func(UArg arg0, UArg arg1)
+{
+    MessageQ_Msg     getMsg;
+    MessageQ_Handle  messageQ;
+    MessageQ_Msg     msg;
+    MessageQ_QueueId remoteQueueId;
+    Int              status;
+    UInt16           msgId = 0;
+#ifdef APPM3_IS_HOST
+    UInt    procId = MultiProc_getId("CORE1");
+#else
+    UInt    procId = MultiProc_getId("HOST");
+#endif
+
+    System_printf("tsk1_func: In tsk1_func.\n");
+
+    /* Get our Transport loaded in absence of Ipc module: */
+    myIpcStart(procId);
+
+    /* Create a message queue. Using SyncSem as the synchronizer */
+    messageQ = MessageQ_create(CORE0_MESSAGEQNAME, NULL);
+    if (messageQ == NULL) {
+        System_abort("MessageQ_create failed\n" );
+    }
+
+    /* No NameServer yet, so assume QueueIndex is same on both M3's: */
+    remoteQueueId = MessageQ_getQueueId(messageQ);
+    System_printf("tsk1_func: created messageQ: QueueID: 0x%x\n",
+            MessageQ_getQueueId(messageQ));
+    /* Force procId to be the destination: */
+    remoteQueueId = (remoteQueueId & 0x0000FFFF) | (procId << 16);
+
+#if 0
+    /* Open the remote message queue. Spin until it is ready. */
+    do {
+        status = MessageQ_open(CORE1_MESSAGEQNAME, &remoteQueueId);
+    }
+    while (status != MessageQ_S_SUCCESS);
+
+    System_printf("tsk1_func: opened remote messageQ.\n");
+#else
+    /*
+     * Wait for other side to create his messageQ.
+     * Remove this hack once MessageQ_open() is implemented.
+     */
+    System_printf("Task Sleep...\n");
+    Task_sleep(1000);
+#endif
+
+    /* Send the message to the core1 and wait for a message from core1 */
+    System_printf("Start the main loop\n");
+    while (msgId < NUMLOOPS) {
+        /* Ping-pong the same message around the processors */
+        msg = MessageQ_alloc(HEAPID, HEAP_MSGSIZE);
+        if (msg == NULL) {
+           System_abort("MessageQ_alloc failed\n" );
+        }
+
+        /* Allow this message to be traced as it goes between processors: */
+        MessageQ_setMsgTrace(msg, TRUE);
+
+        /* Increment: the remote side will check this */
+        msgId++;
+        MessageQ_setMsgId(msg, msgId);
+
+        System_printf("Sending a message #%d to core %d\n", msgId, procId);
+
+        status = MessageQ_put(remoteQueueId, msg);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("MessageQ_put had a failure/error\n");
+        }
+
+        /* Get a message */
+        status = MessageQ_get(messageQ, &getMsg, MessageQ_FOREVER);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("This should not happen since timeout is forever\n");
+        }
+
+        System_printf("Received message #%d from core %d\n",
+                     MessageQ_getMsgId(getMsg), procId);
+
+        /* test id of message received */
+        if (MessageQ_getMsgId(getMsg) != msgId) {
+            System_abort("The id received is incorrect!\n");
+        }
+
+        MessageQ_free(getMsg);
+    }
+
+    System_printf("Test complete!\n");
+    System_exit(0);
+}
+
+/*
+ *  ======== main ========
+ */
+Int main(Int argc, Char* argv[])
+{
+    Error_Block            eb;
+    Ptr                    buf;
+    HeapBuf_Handle         heapHandle;
+    HeapBuf_Params         heapBufParams;
+
+    System_printf("%d resources at 0x%x\n",
+                  sizeof(resources) / sizeof(struct resource), resources);
+
+    /* Initialize the Error_Block. This is required before using it */
+    Error_init(&eb);
+
+    System_printf("main: MultiProc id = %d\n", MultiProc_self());
+
+    buf = Memory_alloc(0, (HEAP_NUMMSGS * HEAP_MSGSIZE) + HEAP_ALIGN, 8, &eb);
+
+    /*
+     *  Create the heap that will be used to allocate messages.
+     */
+    HeapBuf_Params_init(&heapBufParams);
+    heapBufParams.align          = 8;
+    heapBufParams.numBlocks      = HEAP_NUMMSGS;
+    heapBufParams.blockSize      = HEAP_MSGSIZE;
+    heapBufParams.bufSize        = HEAP_NUMMSGS * HEAP_MSGSIZE;
+    heapBufParams.buf            = buf;
+    heapHandle = HeapBuf_create(&heapBufParams, &eb);
+    if (heapHandle == NULL) {
+        System_abort("HeapBuf_create failed\n" );
+    }
+
+    /* Register this heap with MessageQ */
+    MessageQ_registerHeap((IHeap_Handle)(heapHandle), HEAPID);
+
+    BIOS_start();
+    return (0);
+}
diff --git a/src/ti/ipc/tests/message_noipc_core0.cfg b/src/ti/ipc/tests/message_noipc_core0.cfg
new file mode 100644
index 0000000..67cf093
--- /dev/null
+++ b/src/ti/ipc/tests/message_noipc_core0.cfg
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+xdc.loadCapsule("tests_common.cfg.xs");
+xdc.includeFile("ti/configs/omap4430/DucatiCore0.cfg");
+xdc.includeFile("ti/configs/omap4430/DucatiAmmu.cfg");
+
diff --git a/src/ti/ipc/tests/message_noipc_core1.c b/src/ti/ipc/tests/message_noipc_core1.c
new file mode 100644
index 0000000..d3aca7f
--- /dev/null
+++ b/src/ti/ipc/tests/message_noipc_core1.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== message_core1.c ========
+ *  message example on a multiprocessor system
+ *
+ *  This is an example program that uses MessageQ to pass a message
+ *  from one core to another.
+ *
+ *  Each processor creates its own MessageQ first and then will try to open
+ *  a remote processor's MessageQ.  Each processor will either create a
+ *  MessageQTransportShm object or open an object that was created by a
+ *  remote processor.  The HeapBuf for MessageQ will only be created
+ *  by one processor and opened by all other processors.
+ */
+
+#include <xdc/std.h>
+#include <string.h>
+
+/*  -----------------------------------XDC.RUNTIME module Headers    */
+#include <xdc/runtime/Error.h>
+#include <xdc/runtime/Assert.h>
+#include <xdc/runtime/Memory.h>
+#include <xdc/runtime/System.h>
+#include <xdc/runtime/IHeap.h>
+#include <xdc/runtime/Diags.h>
+
+/*  ----------------------------------- IPC module Headers           */
+#include <ti/ipc/MessageQ.h>
+#include <ti/ipc/MultiProc.h>
+#include <ti/ipc/transports/TransportVirtioSetup.h>
+
+/*  ----------------------------------- BIOS6 module Headers         */
+#include <ti/sysbios/BIOS.h>
+#include <ti/sysbios/heaps/HeapBuf.h>
+#include <ti/sysbios/knl/Task.h>
+
+/*  ----------------------------------- To get globals from .cfg Header */
+#include <xdc/cfg/global.h>
+
+/*
+ * TBD: This to get the TransportVirtio_attach() called in lieu of "correct"
+ * way to hook in to BIOS Ipc_start().
+ * Must be done after BIOS_start(), as TransportVirtio startup relies on
+ * passing an interrupt handshake.
+ */
+void myIpcStart()
+{
+    Int     status;
+    UInt    sysm3ProcId = MultiProc_getId("CORE0");
+
+    /* call TransportCircSetup attach to remote processor */
+    status = TransportVirtioSetup_attach(sysm3ProcId, 0);
+
+    Assert_isTrue(status >= 0, NULL);
+}
+
+
+/*
+ *  ======== tsk1_func ========
+ *  Receive and return messages
+ */
+Void tsk1_func(UArg arg0, UArg arg1)
+{
+    MessageQ_Msg     msg;
+    MessageQ_QueueId remoteQueueId;
+    MessageQ_Msg     getMsg;
+    MessageQ_Handle  messageQ;
+    Int              status;
+    UInt16           msgId = 0;
+    UInt             sysm3ProcId = MultiProc_getId("CORE0");
+
+    System_printf("tsk1_func: In tsk1_func.\n");
+
+    /* Get our Transport loaded in absence of Ipc module: */
+    myIpcStart();
+
+    /* Create a message queue. Using SyncSem as the synchronizer */
+    messageQ = MessageQ_create(CORE1_MESSAGEQNAME, NULL);
+    if (messageQ == NULL) {
+        System_abort("MessageQ_create failed\n" );
+    }
+
+    /* No NameServer yet, so assume QueueId is same on both M3's: */
+    remoteQueueId = MessageQ_getQueueId(messageQ);
+    System_printf("tsk1_func: created messageQ: QueueID: 0x%x\n",
+                   remoteQueueId);
+
+    /* Force procId to be the destination: */
+    remoteQueueId = (remoteQueueId & 0x0000FFFF) | (sysm3ProcId << 16);
+
+#if 0
+    /* Open the remote message queue. Spin until it is ready. */
+    do {
+        status = MessageQ_open(CORE0_MESSAGEQNAME, &remoteQueueId);
+    }
+    while (status != MessageQ_S_SUCCESS);
+
+    System_printf("tsk1_func: opened remote messageQ.\n");
+#else
+    /*
+     * Give enough time for other side to create his messageQ.
+     * Remove this hack once MessageQ_open() is implemented, which will
+     * provide the expected sync mechanism over NameServer.
+     */
+    System_printf("Task Sleep...\n");
+    Task_sleep(1000);
+#endif
+
+    /* Send the message to the core1 and wait for a message from core1 */
+    System_printf("Start the main loop\n");
+    while (msgId < NUMLOOPS) {
+        /* Ping-pong the same message around the processors */
+        msg = MessageQ_alloc(HEAPID, HEAP_MSGSIZE);
+        if (msg == NULL) {
+           System_abort("MessageQ_alloc failed\n" );
+        }
+
+        /* Allow this message to be traced as it goes between processors: */
+        MessageQ_setMsgTrace(msg, TRUE);
+
+        /* Increment...the remote side will check this */
+        msgId++;
+        MessageQ_setMsgId(msg, msgId);
+
+        System_printf("Sending a message #%d to core %d\n", msgId, sysm3ProcId);
+
+        status = MessageQ_put(remoteQueueId, msg);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("MessageQ_put had a failure/error\n");
+        }
+
+        /* Get a message */
+        status = MessageQ_get(messageQ, &getMsg, MessageQ_FOREVER);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("This should not happen since timeout is forever\n");
+        }
+
+        System_printf("Received message #%d from core %d\n",
+                       MessageQ_getMsgId(getMsg), sysm3ProcId);
+
+        /* test id of message received */
+        if (MessageQ_getMsgId(getMsg) != msgId) {
+            System_abort("The id received is incorrect!\n");
+        }
+        MessageQ_free(getMsg);
+    }
+
+    System_printf("Test complete!\n");
+    System_exit(0);
+}
+
+/*
+ *  ======== main ========
+ */
+Int main(Int argc, Char* argv[])
+{
+    Error_Block            eb;
+    Ptr                    buf;
+    HeapBuf_Handle         heapHandle;
+    HeapBuf_Params         heapBufParams;
+
+    /* Initialize the Error_Block. This is required before using it */
+    Error_init(&eb);
+
+    System_printf("main: MultiProc id = %d\n", MultiProc_self());
+
+    buf = Memory_alloc(0, (HEAP_NUMMSGS * HEAP_MSGSIZE) + HEAP_ALIGN, 8, &eb);
+
+    /*
+     *  Create the heap that will be used to allocate messages.
+     */
+    HeapBuf_Params_init(&heapBufParams);
+    heapBufParams.align          = 8;
+    heapBufParams.numBlocks      = HEAP_NUMMSGS;
+    heapBufParams.blockSize      = HEAP_MSGSIZE;
+    heapBufParams.bufSize        = HEAP_NUMMSGS * HEAP_MSGSIZE;
+    heapBufParams.buf            = buf;
+    heapHandle = HeapBuf_create(&heapBufParams, &eb);
+    if (heapHandle == NULL) {
+        System_abort("HeapBuf_create failed\n" );
+    }
+
+    /* Register this heap with MessageQ */
+    MessageQ_registerHeap((IHeap_Handle)(heapHandle), HEAPID);
+
+    BIOS_start();
+    return (0);
+}
diff --git a/src/ti/ipc/tests/message_noipc_core1.cfg b/src/ti/ipc/tests/message_noipc_core1.cfg
new file mode 100644
index 0000000..993b8b5
--- /dev/null
+++ b/src/ti/ipc/tests/message_noipc_core1.cfg
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+xdc.loadCapsule("tests_common.cfg.xs");
+xdc.includeFile("ti/configs/omap4430/DucatiCore1.cfg");
+xdc.includeFile("ti/configs/omap4430/DucatiAmmu.cfg");
+
diff --git a/src/ti/ipc/tests/messageq_bench.cfg b/src/ti/ipc/tests/messageq_bench.cfg
new file mode 100644
index 0000000..d59ddda
--- /dev/null
+++ b/src/ti/ipc/tests/messageq_bench.cfg
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  The SysMin used here vs StdMin, as trace buffer address is required for
+ *  Linux trace debug driver, plus provides better performance.
+ */
+var System      = xdc.useModule('xdc.runtime.System');
+var SysMin      = xdc.useModule('xdc.runtime.SysMin');
+System.SupportProxy = SysMin;
+SysMin.bufSize  = 0x8000;
+
+var Memory   = xdc.useModule('xdc.runtime.Memory');
+
+/* Modules used in the virtqueue/TransportVirtio/ServiceMgr libraries: */
+var Semaphore   = xdc.useModule('ti.sysbios.knl.Semaphore');
+var BIOS        = xdc.useModule('ti.sysbios.BIOS');
+BIOS.heapSize   = 0x20000;
+
+var SyncSem   = xdc.useModule('ti.sysbios.syncs.SyncSem');
+var HeapBuf   = xdc.useModule('ti.sysbios.heaps.HeapBuf');
+var List      = xdc.useModule('ti.sdo.utils.List');
+var GateSwi   = xdc.useModule('ti.sysbios.gates.GateSwi');
+var Task      = xdc.useModule('ti.sysbios.knl.Task');
+Task.deleteTerminatedTasks = true;
+var MessageQ  = xdc.useModule('ti.sdo.ipc.MessageQ');
+MessageQ.traceFlag = false;
+MessageQ.SetupTransportProxy = xdc.module('ti.ipc.transports.TransportVirtioSetup');
+
+xdc.loadPackage('ti.ipc.rpmsg');
+
+/* Reduces code size, by only pulling in modules explicitly referenced: */
+BIOS.libType    = BIOS.LibType_Custom;
+
+/* Modules used in Power Management */
+xdc.loadPackage('ti.pm');
+var Power = xdc.useModule('ti.sysbios.family.arm.ducati.omap4430.Power');
+Power.loadSegment = "PM_DATA";
+
+var Idle = xdc.useModule('ti.sysbios.knl.Idle');
+/* IpcPower idle function must be at the end */
+Idle.addFunc('&IpcPower_idle');
+
+var Assert = xdc.useModule('xdc.runtime.Assert');
+var Defaults = xdc.useModule('xdc.runtime.Defaults');
+var Diags = xdc.useModule('xdc.runtime.Diags');
+var LoggerSys = xdc.useModule('xdc.runtime.LoggerSys');
+var LoggerSysParams = new LoggerSys.Params();
+
+/* Enable Logger: */
+Defaults.common$.logger = null ; //LoggerSys.create(LoggerSysParams);
+
+var TransportVirtio = xdc.useModule('ti.ipc.transports.TransportVirtio');
+
+var Main = xdc.useModule('xdc.runtime.Main');
+
+var Hwi = xdc.useModule('ti.sysbios.family.arm.m3.Hwi');
+Hwi.enableException = true;
+
+/*
+ *  Common constants:
+ */
+Program.global.CORE0_MESSAGEQNAME = "CORE0";
+Program.global.CORE1_MESSAGEQNAME = "CORE1";
+Program.global.HEAP_NAME    = "myHeap";
+Program.global.HEAP_ALIGN   =     8;
+Program.global.HEAP_MSGSIZE =    64;
+Program.global.HEAP_NUMMSGS =    256; // Worst case: # recv msgs in vring
+Program.global.HEAPID       =     0;
+
+/* Number of times to run the loop */
+Program.global.NUMLOOPS = 1000;  // was 10
+
+/* Task that does the notify sending */
+Program.global.tsk1 = Task.create('&tsk1_func');
+Program.global.tsk1.instance.name = "tsk1";
+
+xdc.includeFile("ti/configs/omap4430/DucatiCore0.cfg");
+xdc.includeFile("ti/configs/omap4430/DucatiAmmu.cfg");
+
diff --git a/src/ti/ipc/tests/messageq_socket.c b/src/ti/ipc/tests/messageq_socket.c
new file mode 100644
index 0000000..b79a519
--- /dev/null
+++ b/src/ti/ipc/tests/messageq_socket.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== messageq_socket.c ========
+ *
+ *  Test for messageq over sockets.
+ *
+ *  Requires:
+ *      tools/messageq_test in rpmsg_3.2_rc1_sock branch of upstream rpmsg.
+ *
+ */
+
+#include <xdc/std.h>
+#include <string.h>
+
+/*  -----------------------------------XDC.RUNTIME module Headers    */
+#include <xdc/runtime/Error.h>
+#include <xdc/runtime/Assert.h>
+#include <xdc/runtime/Memory.h>
+#include <xdc/runtime/System.h>
+#include <xdc/runtime/IHeap.h>
+#include <xdc/runtime/Diags.h>
+
+/*  ----------------------------------- IPC module Headers           */
+#include <ti/ipc/MessageQ.h>
+#include <ti/ipc/MultiProc.h>
+#include <ti/ipc/transports/TransportVirtioSetup.h>
+#include <ti/ipc/transports/_TransportVirtio.h>
+
+/*  ----------------------------------- BIOS6 module Headers         */
+#include <ti/sysbios/BIOS.h>
+#include <ti/sysbios/heaps/HeapBuf.h>
+
+/*  ----------------------------------- To get globals from .cfg Header */
+#include <xdc/cfg/global.h>
+
+typedef unsigned int u32;
+#include <ti/resources/rsc_table.h>
+
+#define RPMSG_MESSAGEQ_PORT         61
+
+void myNameMap_register(Char * name, UInt32 port)
+{
+    System_printf("registering %s service on %d with HOST\n", name, port);
+    sendRpmsg(name, port, RPMSG_NS_CREATE);
+}
+
+/*
+ * TBD: This to get the TransportVirtio_attach() called in lieu of "correct"
+ * way to hook in to BIOS Ipc_start().
+ * Must be done after BIOS_start(), as TransportVirtio startup relies on
+ * passing an interrupt handshake.
+ */
+void myIpcStart(UInt procId)
+{
+    Int     status;
+
+    /* call TransportCircSetup to attach to remote processor */
+    status = TransportVirtioSetup_attach(procId, 0);
+
+    Assert_isTrue(status >= 0, NULL);
+
+    /*
+     * Wait for other side to create his nameservice.
+     * We really need a handshake in this virtio layer.
+     */
+    System_printf("Task Sleep...\n");
+    Task_sleep(1000);
+
+    /*
+     * Tell the Linux host we have a MessageQ service over rpmsg.
+     *
+     * TBD: This should be in the VirtioTransport initialization, but we need
+     * an interrupt handshake after BIOS_start().
+     * TBD: Also, NameMap should go over a bare rpmsg API, rather than
+     * MessageQCopy, as this clashes with MessageQ.
+     */
+    myNameMap_register("rpmsg-proto", RPMSG_MESSAGEQ_PORT);
+}
+
+/*
+ *  ======== tsk1_func ========
+ *  Receive and return messages
+ */
+Void tsk1_func(UArg arg0, UArg arg1)
+{
+    MessageQ_Msg     getMsg;
+    MessageQ_Handle  messageQ;
+    MessageQ_QueueId remoteQueueId;
+    Int              status;
+    UInt16           msgId = 0;
+    UInt             procId = MultiProc_getId("HOST");
+
+    System_printf("tsk1_func: In tsk1_func.\n");
+
+    /* Get our Transport loaded in absence of Ipc module: */
+    myIpcStart(procId);
+
+    /* Create a message queue. Using SyncSem as the synchronizer */
+    messageQ = MessageQ_create(CORE0_MESSAGEQNAME, NULL);
+    if (messageQ == NULL) {
+        System_abort("MessageQ_create failed\n" );
+    }
+
+    /* No NameServer yet, so assume QueueIndex is same on both M3's: */
+    remoteQueueId = MessageQ_getQueueId(messageQ);
+    System_printf("tsk1_func: created messageQ: QueueID: 0x%x\n",
+            MessageQ_getQueueId(messageQ));
+    /* Force procId to be the destination: */
+    remoteQueueId = (remoteQueueId & 0x0000FFFF) | (procId << 16);
+
+#if 0   // TBD: Need to implement NameServer.
+    /* Open the remote message queue. Spin until it is ready. */
+    do {
+        status = MessageQ_open(CORE1_MESSAGEQNAME, &remoteQueueId);
+    }
+    while (status != MessageQ_S_SUCCESS);
+
+    System_printf("tsk1_func: opened remote messageQ.\n");
+#endif
+
+    System_printf("Start the main loop\n");
+    while (msgId < NUMLOOPS) {
+        /* Get a message */
+        status = MessageQ_get(messageQ, &getMsg, MessageQ_FOREVER);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("This should not happen since timeout is forever\n");
+        }
+
+#ifndef BENCHMARK
+        System_printf("Received message #%d from core %d\n",
+                     MessageQ_getMsgId(getMsg), procId);
+#endif
+        /* test id of message received */
+        if (MessageQ_getMsgId(getMsg) != msgId) {
+            System_abort("The id received is incorrect!\n");
+        }
+
+#ifndef BENCHMARK
+        /* Send it back */
+        System_printf("Sending message Id #%d to core %d\n", msgId, procId);
+#endif
+        status = MessageQ_put(remoteQueueId, getMsg);
+        if (status != MessageQ_S_SUCCESS) {
+           System_abort("MessageQ_put had a failure/error\n");
+        }
+        msgId++;
+    }
+
+    System_printf("Test complete!\n");
+    System_exit(0);
+}
+
+/*
+ *  ======== main ========
+ */
+Int main(Int argc, Char* argv[])
+{
+    Error_Block            eb;
+    Ptr                    buf;
+    HeapBuf_Handle         heapHandle;
+    HeapBuf_Params         heapBufParams;
+
+    System_printf("%d resources at 0x%x\n",
+                  sizeof(resources) / sizeof(struct resource), resources);
+
+    /* Initialize the Error_Block. This is required before using it */
+    Error_init(&eb);
+
+    System_printf("main: MultiProc id = %d\n", MultiProc_self());
+
+    buf = Memory_alloc(0, (HEAP_NUMMSGS * HEAP_MSGSIZE) + HEAP_ALIGN, 8, &eb);
+
+    /*
+     *  Create the heap that will be used to allocate messages.
+     */
+    HeapBuf_Params_init(&heapBufParams);
+    heapBufParams.align          = 8;
+    heapBufParams.numBlocks      = HEAP_NUMMSGS;
+    heapBufParams.blockSize      = HEAP_MSGSIZE;
+    heapBufParams.bufSize        = HEAP_NUMMSGS * HEAP_MSGSIZE;
+    heapBufParams.buf            = buf;
+    heapHandle = HeapBuf_create(&heapBufParams, &eb);
+    if (heapHandle == NULL) {
+        System_abort("HeapBuf_create failed\n" );
+    }
+
+    /* Register this heap with MessageQ */
+    MessageQ_registerHeap((IHeap_Handle)(heapHandle), HEAPID);
+
+    BIOS_start();
+    return (0);
+}
diff --git a/src/ti/ipc/tests/messageq_socket.cfg b/src/ti/ipc/tests/messageq_socket.cfg
new file mode 100644
index 0000000..67cf093
--- /dev/null
+++ b/src/ti/ipc/tests/messageq_socket.cfg
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+xdc.loadCapsule("tests_common.cfg.xs");
+xdc.includeFile("ti/configs/omap4430/DucatiCore0.cfg");
+xdc.includeFile("ti/configs/omap4430/DucatiAmmu.cfg");
+
diff --git a/src/ti/ipc/tests/package.bld b/src/ti/ipc/tests/package.bld
new file mode 100644
index 0000000..70c8dc0
--- /dev/null
+++ b/src/ti/ipc/tests/package.bld
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== package.bld ========
+ *
+ */
+
+var testBld = xdc.loadCapsule("ti/sdo/ipc/build/test.bld");
+var commonBld = xdc.loadCapsule("ti/sdo/ipc/build/common.bld");
+
+/*
+ *  Export everything necessary to build this package with (almost) no
+ *  generated files.  This also exports subdirectories like 'golden'
+ *  and 'docs'.
+ */
+Pkg.attrs.exportAll = true;
+
+/*
+ *  ======== testArray ========
+ *  See ti/bios/build/test.bld. Only the test name is required.
+ *
+ *  Example:
+ *    var testArray = [
+ *        {name: Test1},
+ *        {name: Test2, sources: ["Test"], config: "Test", refOutput: "Test", timeout: "15", buildTargets: ["C64", "C28_large"]}
+ *    ];
+ */
+
+var testArray = [
+    {name: 'messageq_socket', buildPlatforms: ["ti.platform.omap4430.core0"]},
+    {name: 'messageq_bench', sources: ["messageq_socket.c"], copts: "-D BENCHMARK", buildPlatforms: ["ti.platform.omap4430.core0"]},
+    {name: 'message_noipc_core0', copts: "-D APPM3_IS_HOST", buildPlatforms: ["ti.platform.omap4430.core0"]},
+    {name: 'message_noipc_core1', buildPlatforms: ["ti.platform.omap4430.core1"]},
+];
+
+arguments = ["profile=debug platform=all"];
+
+testBld.buildTests(testArray, arguments);
+
diff --git a/src/ti/ipc/tests/package.xdc b/src/ti/ipc/tests/package.xdc
new file mode 100644
index 0000000..839086f
--- /dev/null
+++ b/src/ti/ipc/tests/package.xdc
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== package.xdc ========
+ *
+ */
+
+/*!
+ *  ======== ti.ipc.tests ========
+ *  Currently not shipping these modules
+ */
+
+package ti.ipc.tests [1,0,0,0] {
+}
diff --git a/src/ti/ipc/tests/package.xs b/src/ti/ipc/tests/package.xs
new file mode 100644
index 0000000..7686c79
--- /dev/null
+++ b/src/ti/ipc/tests/package.xs
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== package.xs ========
+ */
+
+/*
+ *  ======== close ========
+ */
+function close()
+{
+}
diff --git a/src/ti/ipc/tests/tests_common.cfg.xs b/src/ti/ipc/tests/tests_common.cfg.xs
new file mode 100644
index 0000000..014244a
--- /dev/null
+++ b/src/ti/ipc/tests/tests_common.cfg.xs
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  The SysMin used here vs StdMin, as trace buffer address is required for
+ *  Linux trace debug driver, plus provides better performance.
+ */
+var System      = xdc.useModule('xdc.runtime.System');
+var SysMin      = xdc.useModule('xdc.runtime.SysMin');
+System.SupportProxy = SysMin;
+SysMin.bufSize  = 0x8000;
+
+var Memory   = xdc.useModule('xdc.runtime.Memory');
+
+/* Modules used in the virtqueue/TransportVirtio/ServiceMgr libraries: */
+var Semaphore   = xdc.useModule('ti.sysbios.knl.Semaphore');
+var BIOS        = xdc.useModule('ti.sysbios.BIOS');
+BIOS.heapSize   = 0x20000;
+
+var SyncSem   = xdc.useModule('ti.sysbios.syncs.SyncSem');
+var HeapBuf   = xdc.useModule('ti.sysbios.heaps.HeapBuf');
+var List      = xdc.useModule('ti.sdo.utils.List');
+var GateSwi   = xdc.useModule('ti.sysbios.gates.GateSwi');
+var Task      = xdc.useModule('ti.sysbios.knl.Task');
+Task.deleteTerminatedTasks = true;
+var MessageQ  = xdc.useModule('ti.sdo.ipc.MessageQ');
+MessageQ.traceFlag = true;
+MessageQ.SetupTransportProxy = xdc.module('ti.ipc.transports.TransportVirtioSetup');
+
+xdc.loadPackage('ti.ipc.rpmsg');
+
+/* Reduces code size, by only pulling in modules explicitly referenced: */
+BIOS.libType    = BIOS.LibType_Custom;
+
+/* Modules used in Power Management */
+xdc.loadPackage('ti.pm');
+var Power = xdc.useModule('ti.sysbios.family.arm.ducati.omap4430.Power');
+Power.loadSegment = "PM_DATA";
+
+var Idle = xdc.useModule('ti.sysbios.knl.Idle');
+/* IpcPower idle function must be at the end */
+Idle.addFunc('&IpcPower_idle');
+
+var Assert = xdc.useModule('xdc.runtime.Assert');
+var Defaults = xdc.useModule('xdc.runtime.Defaults');
+var Diags = xdc.useModule('xdc.runtime.Diags');
+var LoggerSys = xdc.useModule('xdc.runtime.LoggerSys');
+var LoggerSysParams = new LoggerSys.Params();
+
+/* Enable Logger: */
+//Defaults.common$.logger = LoggerSys.create(LoggerSysParams);
+
+/* Enable runtime Diags_setMask() for non-XDC spec'd modules: */
+var Text = xdc.useModule('xdc.runtime.Text');
+Text.isLoaded = true;
+var Registry = xdc.useModule('xdc.runtime.Registry');
+Registry.common$.diags_ENTRY = Diags.RUNTIME_ON;
+Registry.common$.diags_EXIT  = Diags.RUNTIME_ON;
+Registry.common$.diags_INFO  = Diags.RUNTIME_ON;
+Registry.common$.diags_LIFECYCLE = Diags.RUNTIME_ON;
+Registry.common$.diags_STATUS = Diags.RUNTIME_ON;
+Registry.common$.diags_USER1 = Diags.RUNTIME_ON;
+Diags.setMaskEnabled = true;
+
+MessageQ.common$.diags_USER1= Diags.ALWAYS_ON;
+
+var TransportVirtio = xdc.useModule('ti.ipc.transports.TransportVirtio');
+TransportVirtio.common$.diags_ENTRY = Diags.RUNTIME_ON;
+TransportVirtio.common$.diags_EXIT  = Diags.RUNTIME_ON;
+TransportVirtio.common$.diags_INFO  = Diags.RUNTIME_ON;
+TransportVirtio.common$.diags_LIFECYCLE = Diags.RUNTIME_ON;
+TransportVirtio.common$.diags_STATUS = Diags.RUNTIME_ON;
+
+var Main = xdc.useModule('xdc.runtime.Main');
+Main.common$.diags_ASSERT = Diags.ALWAYS_ON;
+Main.common$.diags_INTERNAL = Diags.ALWAYS_ON;
+Main.common$.diags_USER1 = Diags.ALWAYS_ON;
+
+var Hwi = xdc.useModule('ti.sysbios.family.arm.m3.Hwi');
+Hwi.enableException = true;
+
+/*
+ *  Common constants:
+ */
+Program.global.CORE0_MESSAGEQNAME = "CORE0";
+Program.global.CORE1_MESSAGEQNAME = "CORE1";
+Program.global.HEAP_NAME    = "myHeap";
+Program.global.HEAP_ALIGN   =     8;
+Program.global.HEAP_MSGSIZE =    64;
+Program.global.HEAP_NUMMSGS =    256; // Worst case: # recv msgs in vring
+Program.global.HEAPID       =     0;
+
+/* Number of times to run the loop */
+Program.global.NUMLOOPS = 100;  // was 10
+
+/* Task that does the notify sending */
+Program.global.tsk1 = Task.create('&tsk1_func');
+Program.global.tsk1.instance.name = "tsk1";
+
diff --git a/src/ti/ipc/transports/TransportVirtio.c b/src/ti/ipc/transports/TransportVirtio.c
new file mode 100644
index 0000000..35553c3
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtio.c
@@ -0,0 +1,575 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtio.c ========
+ *
+ *  Notes:
+ *  - The logic in the functions for sending (_put()) and receiving _swiFxn()
+ *    depend on the role (host or slave) the processor is playing in the
+ *    assymetric virtio I/O.
+ *  - The host always adds *available* buffers to send/receive, while the slave
+ *    always adds *used* buffers to send/recieve.
+ *  - The logic is summarized below:
+ *
+ *    Host:
+ *    - Prime vq_host with avail bufs, and kick vq_host so slave can send.
+ *    - To send a buffer to the slave processor:
+ *          allocate a tx buffer, or get_used_buf(vq_slave);
+ *               >> copy data into buf <<
+ *          add_avail_buf(vq_slave);
+ *          kick(vq_slave);
+ *    - To receive buffer from slave processor:
+ *          get_used_buf(vq_host);
+ *              >> empty data from buf <<
+ *          add_avail_buf(vq_host);
+ *          kick(vq_host);
+ *
+ *    Slave:
+ *    - To receive buffer from the host:
+ *          get_avail_buf(vq_slave);
+ *              >> empty data from buf <<
+ *          add_used_buf(vq_slave);
+ *          kick(vq_slave);
+ *    - To send buffer to the host:
+ *          get_avail_buf(vq_host);
+ *              >> copy data into buf <<
+ *          add_used_buf(vq_host);
+ *          kick(vq_host);
+ *
+ */
+
+#include <string.h>
+
+#include <xdc/std.h>
+
+#include <xdc/runtime/System.h>
+#include <xdc/runtime/Assert.h>
+#include <xdc/runtime/Error.h>
+#include <xdc/runtime/Memory.h>
+#include <xdc/runtime/Main.h>
+#include <xdc/runtime/Registry.h>
+#include <xdc/runtime/Log.h>
+#include <xdc/runtime/Diags.h>
+
+#include <ti/sysbios/knl/Swi.h>
+#include <ti/sysbios/gates/GateSwi.h>
+
+#include "package/internal/TransportVirtio.xdc.h"
+
+#include <ti/sdo/utils/_MultiProc.h>
+#include <ti/sdo/ipc/_MessageQ.h>
+
+#include <ti/ipc/rpmsg/virtio_ring.h>
+#include <ti/ipc/rpmsg/VirtQueue.h>
+#include <ti/ipc/rpmsg/_VirtQueue.h>
+
+#include <ti/ipc/transports/_TransportVirtio.h>
+
+/* TBD: until NameMap built over a new rpmsg API: */
+static VirtQueue_Handle vq_host;
+
+/* RPMSG Header: Must match rpmsg_hdr in rpmsg.h on Linux side.  */
+typedef struct RpMsg_Header {
+    Bits32 srcAddr;                 /* source endpoint addr               */
+    Bits32 dstAddr;                 /* destination endpoint addr          */
+    Bits32 reserved;                /* reserved                           */
+    Bits16 dataLen;                 /* data length                        */
+    Bits16 flags;                   /* bitmask of different flags         */
+    UInt8  payload[];               /* Data payload                       */
+} RpMsg_Header;
+
+typedef RpMsg_Header *RpMsg_Msg;
+
+/* Maximum RPMSG payload: */
+#define MAX_PAYLOAD (RP_MSG_BUF_SIZE - sizeof(RpMsg_Header))
+
+/* That special per processor RPMSG channel reserved to multiplex MessageQ */
+#define RPMSG_MESSAGEQ_PORT         61
+
+static GateSwi_Handle gateSwi;
+
+#define FXNN "callback_usedBufReady"
+static Void callback_usedBufReady(VirtQueue_Handle vq)
+{
+    Log_print2(Diags_INFO, FXNN": vq %d kicked; VirtQueue_isHost: 0x%x",
+            vq->id, VirtQueue_isHost(vq));
+    if (VirtQueue_isHost(vq))  {
+        /* Post a SWI to process all incoming messages */
+        Swi_post((Swi_Handle)vq->arg);
+    }
+    else {
+        /* Note: We post nothing for vq_slave. */
+       Log_print0(Diags_INFO, FXNN": Not posting SWI");
+    }
+}
+#undef FXNN
+
+
+#define FXNN "callback_availBufReady"
+static Void callback_availBufReady(VirtQueue_Handle vq)
+{
+    Log_print2(Diags_INFO, FXNN": vq %d kicked; VirtQueue_isSlave: 0x%x",
+            vq->id, VirtQueue_isSlave(vq));
+    if (VirtQueue_isSlave(vq))  {
+        /* Post a SWI to process all incoming messages */
+        Swi_post((Swi_Handle)vq->arg);
+    }
+    else {
+       /* Note: We post nothing for vq_host, as we assume the
+        * host has already made all buffers available for slave to send.
+        */
+       Log_print0(Diags_INFO, FXNN": Not posting SWI");
+    }
+}
+#undef FXNN
+
+/* Allocate a buffer for sending: */
+#define FXNN "getTxBuf"
+static Void *getTxBuf(TransportVirtio_Object *obj, VirtQueue_Object *vq)
+{
+        Void     *buf;
+
+        /*
+         * either pick the next unused tx buffer
+         * (half of our buffers are used for sending messages)
+         */
+        if (obj->last_sbuf < RP_MSG_NUM_BUFS)  {
+           Log_print1(Diags_INFO, FXNN": last_sbuf: %d", obj->last_sbuf);
+           buf = (Char *)obj->sbufs + RP_MSG_BUF_SIZE * obj->last_sbuf++;
+        }
+        else {
+           /* or recycle a used one */
+           buf = VirtQueue_getUsedBuf(vq);
+        }
+        return (buf);
+}
+#undef FXNN
+
+
+/*
+ *************************************************************************
+ *                       Instance functions
+ *************************************************************************
+ */
+
+/*
+ *  ======== TransportVirtio_Instance_init ========
+ *
+ */
+#define FXNN "TransportVirtio_Instance_init"
+Int TransportVirtio_Instance_init(TransportVirtio_Object *obj,
+        UInt16 remoteProcId, const TransportVirtio_Params *params,
+        Error_Block *eb)
+{
+    Bool        flag;
+    Swi_Handle  swiHandle;
+    Swi_Params  swiParams;
+    GateSwi_Params gatePrms;
+    Int         i;
+    Ptr         buf_addr = (Ptr)IPU_MEM_VRING0;
+    VirtQueue_callback callback;
+
+    /* set object fields */
+    obj->priority     = params->priority;
+    obj->remoteProcId = remoteProcId;
+
+    /*
+     *  From the remoteProcId, we must determine if this Virtio Transport is
+     *  acting as host or a slave.
+     *  Here, we have this hardcoded, but ideally there needs to be some
+     *  nice XDC config way to create the pairwise host/slave IPC table.
+     */
+    obj->isHost = (MultiProc_self() == MultiProc_getId("CORE1")) ||
+                  (MultiProc_self() == MultiProc_getId("HOST"));
+
+    Log_print2(Diags_INFO, FXNN": remoteProc: %d, isHost: %d",
+                  obj->remoteProcId, obj->isHost);
+
+    swiHandle = TransportVirtio_Instance_State_swiObj(obj);
+
+    /* construct the Swi to process incoming messages: */
+    Swi_Params_init(&swiParams);
+    swiParams.arg0 = (UArg)obj;
+    Swi_construct(Swi_struct(swiHandle),
+                 (Swi_FuncPtr)TransportVirtio_swiFxn,
+                 &swiParams, eb);
+
+    /* Construct a GateSwi to protect our vrings: */
+    GateSwi_Params_init(&gatePrms);
+
+
+    gateSwi = GateSwi_create(&gatePrms, NULL);
+
+    /*
+     * Plug Vring Interrupts...
+     */
+    VirtQueue_startup(obj->isHost);
+
+    /*
+     * Create a pair VirtQueues (one for sending, one for receiving).
+     * Note: First one gets an even, second gets odd vq ID.
+     */
+    if (obj->isHost)  {
+        callback = callback_usedBufReady;
+    }
+    else {
+        callback = callback_availBufReady;
+    }
+
+    vq_host = obj->vq_host   = (Ptr)VirtQueue_create(callback, remoteProcId,
+                                (UArg)swiHandle);
+    obj->vq_slave  = (Ptr)VirtQueue_create(callback, remoteProcId,
+                                (UArg)swiHandle);
+
+    /* Register the transport with MessageQ */
+    flag = ti_sdo_ipc_MessageQ_registerTransport(
+        TransportVirtio_Handle_upCast(obj), remoteProcId, params->priority);
+
+    if (obj->isHost)  {
+       /* Initialize fields used by getTxBuf(): */
+	obj->sbufs = (Char *)buf_addr + RP_MSG_NUM_BUFS * RP_MSG_BUF_SIZE;
+	obj->last_sbuf = 0;
+
+       /* Host needs to prime his vq with some buffers for receiving: */
+       for (i = 0; i < RP_MSG_NUM_BUFS; i++) {
+            VirtQueue_addAvailBuf(obj->vq_host,
+                                  ((Char *)buf_addr + i * RP_MSG_BUF_SIZE));
+       }
+       VirtQueue_kick(obj->vq_host);
+    }
+
+    if (flag == FALSE) {
+        return (2);
+    }
+
+    return (0);
+}
+#undef FXNN
+
+/*
+ *  ======== TransportVirtio_Instance_finalize ========
+ */
+#define FXNN "TransportVirtio_Instance_finalize"
+Void TransportVirtio_Instance_finalize(TransportVirtio_Object *obj, Int status)
+{
+    Swi_Handle  swiHandle;
+
+    Log_print0(Diags_ENTRY, "--> "FXNN);
+
+    switch(status) {
+        case 0: /* MessageQ_registerTransport succeeded */
+            ti_sdo_ipc_MessageQ_unregisterTransport(obj->remoteProcId,
+                obj->priority);
+
+            /* fall thru OK */
+        case 1: /* NOT USED: Notify_registerEventSingle failed */
+        case 2: /* MessageQ_registerTransport failed */
+            break;
+    }
+
+    /* Destruct the swi */
+    swiHandle = TransportVirtio_Instance_State_swiObj(obj);
+    if (swiHandle != NULL) {
+        Swi_destruct(Swi_struct(swiHandle));
+    }
+
+   GateSwi_delete(&gateSwi);
+#undef FXNN
+}
+
+/*
+ *  ======== TransportVirtio_put ========
+ *
+ *  Notes: In keeping with the semantics of IMessageQTransport_put(), we
+ *  simply return FALSE if the remote proc has made no buffers available in the
+ *  vring.
+ *  Otherwise, we could block here, waiting for the remote proc to add a buffer.
+ *  This implies that the remote proc must always have buffers available in the
+ *  vring in order for this side to send without failing!
+ *
+ *  Also, this is a copy-transport, to match the Linux side rpmsg.
+ */
+#define FXNN "TransportVirtio_put"
+Bool TransportVirtio_put(TransportVirtio_Object *obj, Ptr msg)
+{
+    Int          status = MessageQ_S_SUCCESS;
+    UInt         msgSize;
+    Int16        token = (-1);
+    IArg         key;
+    RpMsg_Msg    rp_msg = NULL;
+
+    Log_print1(Diags_ENTRY, "--> "FXNN": Entered: isHost: %d",
+                 obj->isHost);
+
+    /* Send to remote processor: */
+    key = GateSwi_enter(gateSwi);  // Protect vring structs.
+    if (obj->isHost)  {
+       rp_msg = getTxBuf(obj, obj->vq_slave);
+    }
+    else {
+       token = VirtQueue_getAvailBuf(obj->vq_host, (Void **)&rp_msg);
+    }
+    GateSwi_leave(gateSwi, key);
+
+    if ((obj->isHost && rp_msg) || token >= 0) {
+        /* Assert msg->msgSize <= vring's max fixed buffer size */
+        msgSize = MessageQ_getMsgSize(msg);
+
+        Assert_isTrue(msgSize <= MAX_PAYLOAD, NULL);
+
+        /* Copy the payload and set message header: */
+        memcpy(rp_msg->payload, (Ptr)msg, msgSize);
+        rp_msg->dataLen  = msgSize;
+        rp_msg->dstAddr  = 1024;       // TBD: Hardcoded rply addr..
+        rp_msg->srcAddr  = RPMSG_MESSAGEQ_PORT;
+        rp_msg->flags    = 0;
+        rp_msg->reserved = 0;
+
+        /* free the app's message */
+        if (((MessageQ_Msg)msg)->heapId != ti_sdo_ipc_MessageQ_STATICMSG) {
+            MessageQ_free(msg);
+        }
+
+        Log_print4(Diags_INFO, FXNN": sending rp_msg: 0x%x from: %d, "
+                   "to: %d, dataLen: %d",
+                  (IArg)rp_msg, (IArg)rp_msg->srcAddr, (IArg)rp_msg->dstAddr,
+                  (IArg)rp_msg->dataLen);
+
+        key = GateSwi_enter(gateSwi);  // Protect vring structs.
+        if (obj->isHost)  {
+            VirtQueue_addAvailBuf(obj->vq_slave, rp_msg);
+            VirtQueue_kick(obj->vq_slave);
+        }
+        else {
+            VirtQueue_addUsedBuf(obj->vq_host, token);
+            VirtQueue_kick(obj->vq_host);
+        }
+        GateSwi_leave(gateSwi, key);
+    }
+    else {
+        status = MessageQ_E_FAIL;
+        Log_print1(Diags_STATUS, FXNN": %s failed!",
+                      (IArg)(obj->isHost? "getTxBuf" : "getAvailBuf"));
+    }
+
+    return (status == MessageQ_S_SUCCESS? TRUE: FALSE);
+}
+#undef FXNN
+
+/*
+ *  ======== TransportVirtio_control ========
+ */
+Bool TransportVirtio_control(TransportVirtio_Object *obj, UInt cmd,
+    UArg cmdArg)
+{
+    return (FALSE);
+}
+
+/*
+ *  ======== TransportVirtio_getStatus ========
+ */
+Int TransportVirtio_getStatus(TransportVirtio_Object *obj)
+{
+    return (0);
+}
+
+/*
+ *************************************************************************
+ *                       Module functions
+ *************************************************************************
+ */
+
+/*
+ *  ======== TransportVirtio_swiFxn ========
+ *
+ */
+#define FXNN "TransportVirtio_swiFxn"
+Void TransportVirtio_swiFxn(UArg arg0, UArg arg1)
+{
+    Int16             token;
+    Bool              bufAdded = FALSE;
+    UInt32            queueId;
+    MessageQ_Msg      msg;
+    MessageQ_Msg      buf = NULL;
+    RpMsg_Msg         rp_msg;
+    UInt              msgSize;
+    TransportVirtio_Object      *obj;
+    Bool              buf_avail = FALSE;
+
+    Log_print0(Diags_ENTRY, "--> "FXNN);
+
+    obj = (TransportVirtio_Object *)arg0;
+
+    /* Process all available buffers: */
+    if (obj->isHost)  {
+        rp_msg = VirtQueue_getUsedBuf(obj->vq_host);
+        buf_avail = (rp_msg != NULL);
+    }
+    else {
+        token = VirtQueue_getAvailBuf(obj->vq_slave, (Void **)&rp_msg);
+        buf_avail = (token >= 0);
+    }
+
+    while (buf_avail) {
+        Log_print4(Diags_INFO, FXNN": \n\tReceived rp_msg: 0x%x from: %d, "
+                   "to: %d, dataLen: %d",
+                  (IArg)rp_msg, (IArg)rp_msg->srcAddr, (IArg)rp_msg->dstAddr,
+                  (IArg)rp_msg->dataLen);
+
+        /* Convert RpMsg_Msg payload into a MessageQ_Msg: */
+        msg = (MessageQ_Msg)rp_msg->payload;
+
+        Log_print4(Diags_INFO, FXNN": \n\tmsg->heapId: %d, "
+                   "msg->msgSize: %d, msg->dstId: %d, msg->msgId: %d\n",
+                   msg->heapId, msg->msgSize, msg->dstId, msg->msgId);
+
+        /* Alloc a message from msg->heapId to copy the msg */
+        msgSize = MessageQ_getMsgSize(msg);
+        buf = MessageQ_alloc(msg->heapId, msgSize);
+
+        /* Make sure buf is not NULL */
+        Assert_isTrue(buf != NULL, NULL);
+
+        /* copy the message to the buffer allocated. */
+        memcpy((Ptr)buf, (Ptr)msg, msgSize);
+
+        /* get the queue id */
+        queueId = MessageQ_getDstQueue(msg);
+
+        /* Pass to desitination queue: */
+        MessageQ_put(queueId, buf);
+
+        if (obj->isHost)  {
+            VirtQueue_addAvailBuf(obj->vq_host, rp_msg);
+        }
+        else {
+            VirtQueue_addUsedBuf(obj->vq_slave, token);
+        }
+        bufAdded = TRUE;
+
+        /* See if there is another one: */
+        if (obj->isHost)  {
+            rp_msg = VirtQueue_getUsedBuf(obj->vq_host);
+            buf_avail = (rp_msg != NULL);
+        }
+        else {
+            token = VirtQueue_getAvailBuf(obj->vq_slave, (Void **)&rp_msg);
+            buf_avail = (token >= 0);
+        }
+    }
+
+    if (bufAdded)  {
+       /* Tell host/slave we've processed the buffers: */
+       VirtQueue_kick(obj->isHost? obj->vq_host: obj->vq_slave);
+    }
+    Log_print0(Diags_EXIT, "<-- "FXNN);
+}
+
+/*
+ *  ======== TransportVirtio_setErrFxn ========
+ */
+Void TransportVirtio_setErrFxn(TransportVirtio_ErrFxn errFxn)
+{
+    /* Ignore the errFxn */
+}
+
+
+/*  --------------  TEMP NameService over VirtQueue ----------------------- */
+
+#define RPMSG_NAME_SIZE 32
+
+typedef unsigned int u32;
+
+struct rpmsg_ns_msg {
+    char name[RPMSG_NAME_SIZE]; /* name of service including 0 */
+    u32 addr;                   /* address of the service */
+    u32 flags;                  /* see below */
+} __packed;
+
+
+#define NAMESERVICE_PORT   53
+
+/* Message Header: Must match rp_msg_hdr in virtio_rp_msg.h on Linux side. */
+typedef struct Rpmsg_Hdr {
+    Bits32 srcAddr;                 /* source endpoint addr               */
+    Bits32 dstAddr;                 /* destination endpoint addr          */
+    Bits32 reserved;                /* reserved                           */
+    Bits16 dataLen;                 /* data length                        */
+    Bits16 flags;                   /* bitmask of different flags         */
+    UInt8  payload[];               /* Data payload                       */
+} Rpmsg_Hdr;
+
+typedef Rpmsg_Hdr *Rpmsg;
+
+void sendRpmsg(Char * name, UInt32 port, enum rpmsg_ns_flags flags)
+{
+    struct rpmsg_ns_msg nsMsg;
+    UInt16 dstProc  = MultiProc_getId("HOST");
+    UInt32 dstEndpt = NAMESERVICE_PORT;
+    UInt32 srcEndpt = port;
+    Ptr    data     = &nsMsg;
+    UInt16 len      = sizeof(nsMsg);
+    Int16             token = 0;
+    Rpmsg             msg;
+    IArg              key;
+
+    strncpy(nsMsg.name, name, RPMSG_NAME_SIZE);
+    nsMsg.addr = port;
+    nsMsg.flags = flags;
+
+    if (dstProc != MultiProc_self()) {
+        /* Send to remote processor: */
+        key = GateSwi_enter(gateSwi);  // Protect vring structs.
+        token = VirtQueue_getAvailBuf(vq_host, (Void **)&msg);
+        GateSwi_leave(gateSwi, key);
+
+        if (token >= 0) {
+            /* Copy the payload and set message header: */
+            memcpy(msg->payload, data, len);
+            msg->dataLen = len;
+            msg->dstAddr = dstEndpt;
+            msg->srcAddr = srcEndpt;
+            msg->flags = 0;
+            msg->reserved = 0;
+
+            key = GateSwi_enter(gateSwi);  // Protect vring structs.
+            VirtQueue_addUsedBuf(vq_host, token);
+            VirtQueue_kick(vq_host);
+            GateSwi_leave(gateSwi, key);
+        }
+        else {
+            System_abort("sendRpmsg: getAvailBuf failed!");
+        }
+    }
+}
+
+
diff --git a/src/ti/ipc/transports/TransportVirtio.xdc b/src/ti/ipc/transports/TransportVirtio.xdc
new file mode 100644
index 0000000..f2505e6
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtio.xdc
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtio.xdc ================
+ */
+
+import ti.sysbios.knl.Swi;
+
+/*!
+ *  ======== TransportVirtio ========
+ *  Transport for MessageQ that uses vring structures.
+ *
+ *  This is a {@link ti.sdo.ipc.MessageQ} transport that utilizes
+ *  a pair of vrings (see Linux virtio) to communicate with a remote processor.
+ *
+ */
+
+@InstanceFinalize
+@InstanceInitError
+
+
+module TransportVirtio inherits ti.sdo.ipc.interfaces.IMessageQTransport
+{
+
+instance:
+
+    /*!
+     *  ======== sharedAddr ========
+     *  Address in shared memory where this instance will be placed
+     *
+     */
+    config Ptr sharedAddr = null;
+
+internal:
+
+    /*!
+     *  ======== swiFxn ========
+     */
+    Void swiFxn(UArg arg0, UArg arg1);
+
+    /*! Instance state structure */
+    struct Instance_State {
+        UInt16       priority;           /* priority to register             */
+        UInt16       remoteProcId;       /* dst proc id                      */
+        Bool         isHost;             /* self proc id acts as a host.     */
+        Swi.Object   swiObj;             /* Each instance has a swi          */
+        Ptr          vq_slave;           /* Slave's VirtQueue Handle         */
+        Ptr          vq_host;            /* Host's VirtQueue Handle          */
+        Ptr          sbufs;              /* Buffers for sending              */
+        UInt16       last_sbuf;          /* Index of last send buffer used   */
+    }
+}
diff --git a/src/ti/ipc/transports/TransportVirtio.xs b/src/ti/ipc/transports/TransportVirtio.xs
new file mode 100644
index 0000000..a6e84de
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtio.xs
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtio.xs ================
+ */
+
+var TransportVirtio  = null;
+var MessageQ         = null;
+var MultiProc        = null;
+var Swi              = null;
+var TransportVirtioSetup   = null;
+
+/*
+ *  ======== module$use ========
+ */
+function module$use()
+{
+    TransportVirtio = this;
+    MultiProc       = xdc.useModule("ti.sdo.utils.MultiProc");
+    MessageQ        = xdc.useModule("ti.sdo.ipc.MessageQ");
+    Swi             = xdc.useModule("ti.sysbios.knl.Swi");
+	TransportVirtioSetup = xdc.useModule("ti.ipc.transports.TransportVirtioSetup");
+	xdc.loadPackage("ti.ipc.rpmsg");
+}
+
+
diff --git a/src/ti/ipc/transports/TransportVirtioSetup.c b/src/ti/ipc/transports/TransportVirtioSetup.c
new file mode 100644
index 0000000..daa8e99
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtioSetup.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtioSetup.c ========
+ */
+
+#include <xdc/std.h>
+#include <xdc/runtime/System.h>
+#include <xdc/runtime/Assert.h>
+#include <xdc/runtime/Error.h>
+
+#include <ti/ipc/transports/TransportVirtio.h>
+
+#include "package/internal/TransportVirtioSetup.xdc.h"
+
+#include <ti/sdo/ipc/_MessageQ.h>
+#include <ti/sdo/utils/_MultiProc.h>
+
+/*
+ *  ======== TransportVirtioSetup_attach ========
+ */
+Int TransportVirtioSetup_attach(UInt16 remoteProcId, Ptr sharedAddr)
+{
+    TransportVirtio_Handle handle;
+    TransportVirtio_Params params;
+    Int status = MessageQ_E_FAIL;
+    Error_Block eb;
+
+    System_printf("TransportVirtioSetup_attach: remoteProcId: %d\n",
+                   remoteProcId);
+
+    Error_init(&eb);
+
+    /* init the transport parameters */
+    TransportVirtio_Params_init(&params);
+    params.sharedAddr = sharedAddr;  /* Not used yet */
+
+    handle = TransportVirtio_create(remoteProcId, &params, &eb);
+
+    if (handle != NULL) {
+       TransportVirtioSetup_module->handles[remoteProcId] = handle;
+       status = MessageQ_S_SUCCESS;
+    }
+
+    return (status);
+}
+
+/*
+ *  ======== TransportVirtioSetup_detach ========
+ */
+Int TransportVirtioSetup_detach(UInt16 remoteProcId)
+{
+    TransportVirtio_Handle handle;
+
+    System_printf("TransportVirtioSetup_detach: remoteProcId: %d\n",
+                   remoteProcId);
+
+    handle = TransportVirtioSetup_module->handles[remoteProcId];
+
+    /* Trying to detach an un-attached processor should fail */
+    if (handle == NULL) {
+        return (MessageQ_E_FAIL);
+    }
+
+    /* Unregister the instance */
+    TransportVirtioSetup_module->handles[remoteProcId] = NULL;
+
+    TransportVirtio_delete(&handle);
+
+    return (MessageQ_S_SUCCESS);
+}
+
+/*
+ *  ======== TransportVirtioSetup_isRegistered ========
+ */
+Bool TransportVirtioSetup_isRegistered(UInt16 remoteProcId)
+{
+    Bool registered;
+
+    registered = (TransportVirtioSetup_module->handles[remoteProcId] != NULL);
+
+    return (registered);
+}
+
+
diff --git a/src/ti/ipc/transports/TransportVirtioSetup.xdc b/src/ti/ipc/transports/TransportVirtioSetup.xdc
new file mode 100644
index 0000000..7654fc6
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtioSetup.xdc
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtioSetup.xdc ========
+ */
+
+/*!
+ *  ======== TransportVirtioSetup ========
+ *  Manages the setup of TransportVirtio instances.
+ *
+ *  create or open the TransportVirtio for each pair of devices.
+ */
+
+module TransportVirtioSetup inherits ti.sdo.ipc.interfaces.ITransportSetup
+{
+
+internal:
+
+    /* Module Status object */
+    struct Module_State {
+        TransportVirtio.Handle handles[]; /* handle per remote proc */
+    }
+}
diff --git a/src/ti/ipc/transports/TransportVirtioSetup.xs b/src/ti/ipc/transports/TransportVirtioSetup.xs
new file mode 100644
index 0000000..2a71e9e
--- /dev/null
+++ b/src/ti/ipc/transports/TransportVirtioSetup.xs
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== TransportVirtioSetup.xs ========
+ */
+
+var TransportVirtioSetup = null;
+var TransportVirtio      = null;
+var MultiProc            = null;
+
+/*
+ *  ======== module$use ========
+ */
+function module$use()
+{
+    TransportVirtioSetup = this;
+    TransportVirtio =
+            xdc.useModule("ti.ipc.transports.TransportVirtio");
+    MultiProc = xdc.useModule("ti.sdo.utils.MultiProc");
+}
+
+/*
+ * ======== module$static$init ========
+ */
+function module$static$init(mod, params)
+{
+    /* set the length of handles to the number of processors */
+    mod.handles.length = MultiProc.numProcessors;
+
+    /* init the remote processor handles to null */
+    for (var i=0; i < mod.handles.length; i++) {
+        mod.handles[i] = null;
+    }
+}
diff --git a/src/ti/ipc/transports/_TransportVirtio.h b/src/ti/ipc/transports/_TransportVirtio.h
new file mode 100644
index 0000000..c9d7488
--- /dev/null
+++ b/src/ti/ipc/transports/_TransportVirtio.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+enum rpmsg_ns_flags {
+    RPMSG_NS_CREATE = 0,
+    RPMSG_NS_DESTROY = 1
+};
+
+extern void sendRpmsg(Char * name, UInt32 port, enum rpmsg_ns_flags flags);
+
diff --git a/src/ti/ipc/transports/package.bld b/src/ti/ipc/transports/package.bld
new file mode 100644
index 0000000..a632772
--- /dev/null
+++ b/src/ti/ipc/transports/package.bld
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2011, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ *  ======== package.bld ========
+ *
+ */
+
+var commonBld = xdc.loadCapsule("ti/sdo/ipc/build/common.bld");
+
+var objList_m3 = [
+      "TransportVirtioSetup",
+      "TransportVirtio",
+];
+
+var trgFilter_m3 = {
+        field: "isa",
+        list: [ "v7M" ]
+};
+
+/* generate makefiles */
+arguments = ["profile=debug platform=all"];
+commonBld.buildLibs(objList_m3, undefined, trgFilter_m3, arguments);
+
+arguments = ["profile=release platform=all"];
+commonBld.buildLibs(objList_m3, undefined, trgFilter_m3, arguments);
+
diff --git a/src/ti/ipc/transports/package.xdc b/src/ti/ipc/transports/package.xdc
new file mode 100644
index 0000000..e7afa82
--- /dev/null
+++ b/src/ti/ipc/transports/package.xdc
@@ -0,0 +1,44 @@
+/* --COPYRIGHT--,BSD
+ * Copyright (c) $(CPYYEAR), Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+/*
+ *  ======== package.xdc ========
+ *
+ */
+
+/*!
+ *  ======== ti.ipc.transports ========
+ */
+
+package ti.ipc.transports [1,0,0,0] {
+    module    TransportVirtio;
+    module    TransportVirtioSetup;
+}
diff --git a/src/ti/ipc/transports/package.xs b/src/ti/ipc/transports/package.xs
new file mode 100644
index 0000000..f83df73
--- /dev/null
+++ b/src/ti/ipc/transports/package.xs
@@ -0,0 +1,97 @@
+/* --COPYRIGHT--,BSD
+ * Copyright (c) $(CPYYEAR), Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+/*
+ *  ======== package.xs ========
+ *
+ *! Revision History
+ *! ================
+ *! 15-Aug-2008 jv	Add call to findSuffix().
+ *! 21-Feb-2007 rvh     Added getLibs() with specific profile behavior.
+ */
+
+
+/*
+ *  ======== Package.getLibs ========
+ *  This function is called when a program's configuration files are
+ *  being generated and it returns the name of a library appropriate
+ *  for the program's configuration.
+ */
+
+function getLibs(prog)
+{
+    var suffix;
+
+    /* find a compatible suffix */
+    if ("findSuffix" in prog.build.target) {
+	suffix = prog.build.target.findSuffix(this);
+    }
+    else {
+	suffix = prog.build.target.suffix;
+    }
+
+    var name = this.$name + ".a" + suffix;
+    var lib = "";
+
+    lib = "lib/" + this.profile + "/" + name;
+    if (java.io.File(this.packageBase + lib).exists()) {
+        return lib;
+    }
+
+    /* all ti.targets return whole_program_debug library by default */
+    if (prog.build.target.$name.match(/^ti\.targets\./)) {
+        lib = "lib/" + "whole_program_debug/" + name;
+        if (java.io.File(this.packageBase + lib).exists()) {
+            return lib;
+        }
+    }
+
+    /* all other targets, return release library by default */
+    else {
+        lib = "lib/" + "release/" + name;
+        if (java.io.File(this.packageBase + lib).exists()) {
+            return lib;
+        }
+    }
+
+    /* could not find any library, throw exception */
+    throw Error("Library not found: " + name);
+}
+
+/*
+ *  ======== package.close ========
+ */
+function close()
+{
+    if (xdc.om.$name != 'cfg') {
+        return;
+    }
+}
-- 
1.6.1

