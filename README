SysLink 3
=========

SysLink3 is the implementation of a minimal set of SysLink2 APIs, 
hosted over the new AMP (rpmsg) feature in Linux kernel v3.x, and the
corresponding support for an rpmsg-based MessageQ Transport on the BIOS side.

The rpmsg functionality is exposed to user space via a socket interface, 
provided in the upstream-rpmsg repo (see below).

The main public API currently supported is MessageQ.

For current constraints, see the TODO section below.

Platforms:
=========
Messaging has been validated between:
1) Linux A9 to BIOS Ducati sysM3 (CORE0), on OMAP4 Panda board.


BUILD:
=====

Linux side:
===========

Kernel space:
------------

1) Clone the upstream-rpmsg repo, and checkout the rpmsg_3.4_rc1 branch:
  * https://github.com/ohadbc/upstream-rpmsg/tree/rpmsg_3.4_rc1

2) The etc/rpmsg_3.4_rc1.config file was used for Panda board during testing.

User space:
-----------

1) Install the BIOS IPC product into the tools REPO directory:
  - See sysbios-rpmsg repo Makefile to get correct IPC version.
  - http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/
2) Clone the following to get the MessageQ library and test sample:
  * git://github.com/GAnthony/syslink3.git
3) Update Makefile.inc to point the REPO variable to find BIOS IPC:
   # Tools REPO:
   REPO = <path to your tools repository>
4) Build:
  % make

BIOS side:
==========

1) Clone the sysbios-rpmsg repo, and checkout the syslink3 branch:
   * https://github.com/GAnthony/sysbios-rpmsg/tree/syslink3
   * Use commit at tag: v0.1_rpmsg_3.4.

2) See the README for tools and build instructions (substitute github repo above
   for the omapzoom repo mentioned in the README).  Use the tools versions 
   listed in the Makefile.

3) Note that the MessageQCopy, srvmgr, resmgr, pm, and grcm modules are
   not currently compatible with the new BIOS IPC transport: TransportVirtio.
   They build, but are not compiled into the test sample: messageq_socket.c.

Test:
====

See the syslink3 repo's etc/ directory for scripts to use on the target:
- load_firmware.sh:   loads remoteproc, virtio and rpmsg modules.
- unload_firmware.sh: unloads modules.
- run_lad.sh:         starts the NameServer daemon (needed by MessageQ).
- dump_trace.sh:      A shortcut to dump the coprocessor trace buffer. 

This was tested using a target root file system (built using machine type:
pandaboard) from: http://narcissus.angstrom-distribution.org/

) Boot Linux on the target: (eg: boot uImage on MMC, and load fs over NFS):
   setenv bootargs 'root=/dev/nfs rw nfsroot=<nfs_server_ip>:<rfs_path> rootdelay=5 console=ttyO2,115200n8 noinitrd ip=dhcp'
   setenv bootcmd 'mmcinit 0;fatload mmc 0:1 0x80000000 uImage; bootm'

2) Copy the messageq_socket.xem3 ELF binary (output of sysbios-rpmsg make) to
   the target /lib/firmware directory, and rename to ducati-m3-core0.xem3.

3) On the target, load the BIOS firmware and rpmsg socket driver:
   (See etc/load_firmware.sh):
   % depmod -a
   % mkdir /debug
   % mount -t debugfs none /debug
   % modprobe remoteproc
   % modprobe omap_remoteproc
   % modprobe virtio_rpmsg_bus
   % modprobe rpmsg_proto

4) To dump the Ducati trace on core 0:
   (See etc/dump_trace.sh):
   % cat /debug/remoteproc/omap-rproc.1/trace0

5a) Start the NameServer daemon: (based on Link Arbiter Daemon):
   (See etc/run_lad.txt):
   % lad lad.txt
   # Optionally pipe out the NameServer printf:
   % tail -f /tmp/LAD/lad.txt

5b) Run MessageQApp (built in src/samples)
   % MessageQApp:

6) Expected Output: Linux side:

MessageQApp
Remote MessageQApp_queueId  [0x10000]

Exchanging messages with remote processor...
MessageQ_get #0 Msg = 0x18398
Exchanged 1 messages with remote processor
MessageQ_get #1 Msg = 0x18398
Exchanged 2 messages with remote processor
[...]
Exchanged 99 messages with remote processor
MessageQ_get #99 Msg = 0x18398
Exchanged 100 messages with remote processor
Sample application successfully completed!
Leaving MessageQApp_execute

Entered MessageQApp_shutdown()
LAD_disconnect() succeeded
Leave MessageQApp_shutdown()

7) Expected Output: BIOS trace:

12 resources at 0x1
main: MultiProc id = 1
tsk1_func: In tsk1_func.
TransportVirtioSetup_attach: remoteProcId: 0
registering rpmsg-proto service on 61 with HOST
tsk1_func: created MessageQ: SLAVE; QueueID: 0x10000
tsk1_func: Calling MessageQ_open...
tsk1_func: Remote MessageQ HOST; QueueID: 0x1
Start the main loop
Received message #0 from core 0
Sending message Id #0 to core 0
Received message #1 from core 0
Sending message Id #1 to core 0
Received message #2 from core 0
Sending message Id #2 to core 0
[...]
Received message #99 from core 0
Sending message Id #99 to core 0
TransportVirtioSetup_detach: remoteProcId: 0
unregistering rpmsg-proto service on 61 with HOST
Test complete!

8) To unload the firmware and stop the coprocessor:
   (See etc/unload_firmware.sh)
   % rmmod rpmsg_proto
   % rmmod virtio_rpmsg_bus
   % rmmod omap_remoteproc
   % rmmod remoteproc

9) To validate the socket without MessageQ, you can build the rpmsg_proto test:
  * See https://github.com/ohadbc/upstream-rpmsg/blob/rpmsg_3.4_rc1/tools/rpmsg_proto.c
  - This is a test program for the rpmsg socket, which assumes the BIOS firmware test_omx_sysm3.xem3 is copied into /lib/firmware/ducati-m3-core0.xem3.
  - To build:
    arm-none-linux-gnueabi-gcc rpmsg_proto.c -o rpmsg_proto
  - Then reboot and load the firmware as above.

Documentation:
==============

* http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/syslink/latest/docs/html/index.html
* https://github.com/ohadbc/upstream-rpmsg/blob/rpmsg_3.4_rc1/Documentation/rpmsg.txt
* https://github.com/ohadbc/upstream-rpmsg/blob/rpmsg_3.4_rc1/Documentation/virtual/virtio-spec.txt
* http://www.omappedia.org/wiki/Syslink_3

TODO:
=====
* Add OSAL, and replace printf in API modules with Log_printf.
* Support multiple processes.
* Optimize performance/benchmark.
* Make TransportVirtio work with MessageQCopy based channels and rpmsg-omx;

